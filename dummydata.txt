phi and theta (comes in as double)
theta (0 - pi)
phi (0 - 2pi)

current torso position: y-axis: 0.4-0.6
                        x-axis: 0-0.9
velocity: deg/s
location: degrees from the hall effect (at the origin)
torque vector is in Newton/meters

// Points in the xy-plane
struct PointType
{
    double x;
    double y;
};

//Use convex hull algorithm to find x and y closest and furthest from the torso

// Sort criterion: points are sorted with respect to their x-coordinate.
//                 If two points have the same x-coordinate then we compare
//                 their y-coordinates
bool sortPoints(const PointType &lhs, const PointType &rhs)
{
    return (lhs.x < rhs.x) || (lhs.x == rhs.x && lhs.y < rhs.y);
}

// Check if three points make a right turn using cross product
bool right_turn(const PointType &P1, const PointType &P2, const PointType &P3)
{
    return ((P3.x - P1.x) * (P2.y - P1.y) - (P3.y - P1.y) * (P2.x - P1.x)) > 0;
}

findDistance() {

        //Find distance of every nearby coil within radial distance
    //Loop through addresses and add to a data structure
    //Determine coils that are within 1 to 3.5cm

    //Store all coils within that distance in a data structure
    //Check if it is a deadzone
    //If it is a deadzone, stall the program for () secs. Do not power on any coils
    ifstream myfile;
    //PointType *points;
    vector<PointType> lowerCH;
    vector<PointType> upperCH;

    // reading data from file
    myfile.open("coilcoordinates.txt");

    if (myfile.is_open())
    {
        vector<PointType> points;
        string line;
        int row = 0;
        while (getline(myfile, line))
        {
            std::stringstream ss(line);
            std::string token;
            int col = 1;

            PointType point;
            while (std::getline(ss, token, ' '))
            {
                if (col == 1)
                {
                    point.x = stod(token);
                }
                else
                {
                    point.y = stod(token);
                }
                col++;
            }
            points.push_back(point);
            row++;
        }
        // for (int i = 0; i < n_points; i++)
        //     myfile >> points[i].x >> points[i].y;

        myfile.close();

        //Sorting points
        //sort(points, points + n_points, sortPoints);
        //cout << "Sorted Points\n";
        //for (int i = 0; i != n_points; ++i)
           // cout << "(" << points[i].x << " , " << points[i].y << ")" << endl;


        //Computing upper convex hull
        upperCH.push_back(points[0]);
        upperCH.push_back(points[1]);

        for (int i = 2; i < points.size(); i++)
        {
            while (upperCH.size() > 1 and (!right_turn(upperCH[upperCH.size() - 2], upperCH[upperCH.size() - 1], points[i])))
                upperCH.pop_back();
            upperCH.push_back(points[i]);
            cout << "Sorted points: " << sortPoints(points[i-2], points[i-1]) << endl; 
        }
        cout << "Furthest coil: " << endl;
        cout << "(" << upperCH[upperCH.size()-1].x << " , " << upperCH[upperCH.size()].y << ")" << endl;

        //Computing lower convex hull
        lowerCH.push_back(points[points.size() - 1]);
        lowerCH.push_back(points[points.size() - 2]);

        for (int i = 2; i < points.size(); i++)
        {
            while (lowerCH.size() > 1 and (!right_turn(lowerCH[lowerCH.size() - 2], lowerCH[lowerCH.size() - 1], points[points.size() - i - 1])))
                lowerCH.pop_back();
            lowerCH.push_back(points[points.size() - i - 1]);
        }
        cout << "Closest coil: " << endl;
        for (int i = 0; i < lowerCH.size(); i++)
            cout << "(" << lowerCH[i].x << " , " << lowerCH[i].y << ")" << endl;
    }
}


Other implementation
    // A utility function to find next to top in a stack
    PointType nextToTop(stack<PointType> &S)
    {
        PointType p = S.top();
        S.pop();
        PointType res = S.top();
        S.push(p);
        return res;
    }
    
    // A utility function to swap two points
    int swap(PointType &p1, PointType &p2)
    {
        PointType temp = p1;
        p1 = p2;
        p2 = temp;
    }
    
    // A utility function to return square of distance between p1 and p2
    int dist(PointType p1, PointType p2)
    {
        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
    }
    
    int orientation(PointType p, PointType q, PointType r)
    {
        int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    
        if (val == 0)
            return 0; // colinear
        return (val > 0) ? 1 : 2; // clock or counterclock wise
    }
    
    // A function used by library function qsort() to sort an array of
    // points with respect to the first point
    int compare(const void *vp1, const void *vp2)
    {
        PointType *p1 = (PointType *) vp1;
        PointType *p2 = (PointType *) vp2;
    
        // Find orientation
        double o = orientation(p0, *p1, *p2);
        if (o == 0)
            return (dist(p0, *p2) >= dist(p0, *p1)) ? -1 : 1;
    
        return (o == 2) ? -1 : 1;
    }
    
    // Prints convex hull of a set of n points.
    void convexHull(PointType points[], int n)
    {
        // Find the bottommost point
        int ymin = points[0].y, min = 0;
        for (int i = 1; i < n; i++)
        {
            int y = points[i].y;
    
            // Pick the bottom-most or chose the left most point in case of tie
            if ((y < ymin) || (ymin == y && points[i].x < points[min].x))
                ymin = points[i].y, min = i;
        }
    
        // Place the bottom-most point at first position
        swap(points[0], points[min]);
    
        // Sort n-1 points with respect to the first point.  A point p1 comes
        // before p2 in sorted ouput if p2 has larger polar angle (in
        // counterclockwise direction) than p1
        p0 = points[0];
        qsort(&points[1], n - 1, sizeof(PointType), compare);
    
        // Create an empty stack and push first three points to it.
        stack<PointType> S;
        S.push(points[0]);
        S.push(points[1]);
        S.push(points[2]);
    
        // Process remaining n-3 points
        for (int i = 3; i < n; i++)
        {
            // Keep removing top while the angle formed by points next-to-top,
            // top, and points[i] makes a non-left turn
            while (orientation(nextToTop(S), S.top(), points[i]) != 2)
                S.pop();
            S.push(points[i]);
        }
    
        // Now stack has the output points, print contents of stack
        while (!S.empty())
        {
            PointType p = S.top();
            cout << "(" << p.x << ", " << p.y << ")" << endl;
            S.pop();
        }
    }

    in main:

    PointType points[] = { { 0, 3 }, { 1, 1 }, { 2, 2 }, { 3, 2 }, { 0, 0 },
            { 1, 2 }, { 3, 1 }, { 3, 3 } };
            
    int n = sizeof(points) / sizeof(points[0]);
    cout << "The points in the convex hull are: \n";
    convexHull(points, n);

    int getClosest(int, int, int); 

Find the closest point in an array example:
  
// Returns element closest to target in arr[] 
int findClosest(int arr[], int n, int target) 
{ 
    // Corner cases 
    if (target <= arr[0]) 
        return arr[0]; 
    if (target >= arr[n - 1]) 
        return arr[n - 1]; 
  
    // Doing binary search 
    int i = 0, j = n, mid = 0; 
    while (i < j) { 
        mid = (i + j) / 2; 
  
        if (arr[mid] == target) 
            return arr[mid]; 
  
        /* If target is less than array element, 
            then search in left */
        if (target < arr[mid]) { 
  
            // If target is greater than previous 
            // to mid, return closest of two 
            if (mid > 0 && target > arr[mid - 1]) 
                return getClosest(arr[mid - 1], 
                                  arr[mid], target); 
  
            /* Repeat for left half */
            j = mid; 
        } 
  
        // If target is greater than mid 
        else { 
            if (mid < n - 1 && target < arr[mid + 1]) 
                return getClosest(arr[mid], 
                                  arr[mid + 1], target); 
            // update i 
            i = mid + 1;  
        } 
    } 
  
    // Only single element left after search 
    return arr[mid]; 
} 
  
// Method to compare which one is the more close. 
// We find the closest by taking the difference 
// between the target and both values. It assumes 
// that val2 is greater than val1 and target lies 
// between these two. 
int getClosest(int val1, int val2, 
               int target) 
{ 
    if (target - val1 >= val2 - target) 
        return val2; 
    else
        return val1; 
} 
  
// Driver code 
int main() 
{ 
    int arr[] = { 1, 2, 4, 5, 6, 6, 8, 9 }; 
    int n = sizeof(arr) / sizeof(arr[0]); 
    int target = 11; 
    cout << (findClosest(arr, n, target)); 
} 